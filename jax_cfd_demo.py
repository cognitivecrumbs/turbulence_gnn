# -*- coding: utf-8 -*-
"""JAX-CFD demo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/google/jax-cfd/blob/main/notebooks/demo.ipynb

# JAX-CFD demo

This initial demonstration shows how to use JAX-CFD to simulate decaying turbulence in 2D.
"""

! pip install jax_cfd

import jax
import jax.numpy as jnp
import jax_cfd.base as cfd
import numpy as np
import seaborn
import xarray

# Commented out IPython magic to ensure Python compatibility.
size = 256
size = 2048
density = 1.
viscosity = 1e-3
seed = 121
inner_steps = 25
outer_steps = 200

max_velocity = 7.0
cfl_safety_factor = 0.5

# Define the physical dimensions of the simulation.
grid = cfd.grids.Grid((size, size), domain=((0, 2 * jnp.pi), (0, 2 * jnp.pi)))

# Construct a random initial velocity. The `filtered_velocity_field` function
# ensures that the initial velocity is divergence free and it filters out
# high frequency fluctuations.
v0 = cfd.initial_conditions.filtered_velocity_field(
    jax.random.PRNGKey(seed), grid, max_velocity)

# Choose a time step.
dt = cfd.equations.stable_time_step(
    max_velocity, cfl_safety_factor, viscosity, grid)

print(dt)

# Define a step function and use it to compute a trajectory.
step_fn = cfd.funcutils.repeated(
    cfd.equations.semi_implicit_navier_stokes(
        density=density, viscosity=viscosity, dt=dt, grid=grid),
    steps=inner_steps)
rollout_fn = jax.jit(cfd.funcutils.trajectory(step_fn, outer_steps))
# %time _, trajectory = jax.device_get(rollout_fn(v0))

# JAX-CFD uses GridVariable objects for input/output. These objects contain:
#  - array data
#  - an "offset" that documents the position on the unit-cell where the data
#    values are located
#  - grid properties
#  - boundary conditions on the variable
with np.printoptions(edgeitems=1):
  for i, u in enumerate(trajectory):
    print(f'Component {i}: {u}')

# load into xarray for visualization and analysis
ds = xarray.Dataset(
    {
        'u': (('time', 'x', 'y'), trajectory[0].data),
        'v': (('time', 'x', 'y'), trajectory[1].data),
    },
    coords={
        'x': grid.axes()[0],
        'y': grid.axes()[1],
        'time': dt * inner_steps * np.arange(outer_steps)
    }
)

ds.to_netcdf("test.nc")

ds

def vorticity(ds):
  return (ds.v.differentiate('x') - ds.u.differentiate('y')).rename('vorticity')

(ds.pipe(vorticity).thin(time=20)
 .plot.imshow(col='time', cmap=seaborn.cm.icefire, robust=True, col_wrap=5));

step_fn_1step = cfd.funcutils.repeated(
    cfd.equations.semi_implicit_navier_stokes(
        density=density, viscosity=viscosity, dt=dt, grid=grid),
    steps=1)

v1 = step_fn_1step(v0)

from jax_cfd.base import finite_differences as fd

divergence = fd.divergence(v1)
print(v1[0].shape)
# dudx = (np.roll(v1[0].data,-1,axis=-2) - np.roll(v1[0].data,1,axis=-2))/(ds.x[1]-ds.x[0]).data/2
# dvdy = (np.roll(v1[1].data,-1,axis=-1) - np.roll(v1[1].data,1,axis=-1))/(ds.y[1]-ds.y[0]).data/2
# dudx = (np.roll(v1[0].data,-1,axis=-2) - v1[0].data)/(ds.x[1]-ds.x[0]).data
# dvdy = (np.roll(v1[1].data,-1,axis=-1) - v1[1].data)/(ds.y[1]-ds.y[0]).data

dudx = (np.roll(v1[0].data,1,axis=-2) - v1[0].data)/(ds.x[1]-ds.x[0]).data
dvdy = (np.roll(v1[1].data,1,axis=-1) - v1[1].data)/(ds.y[1]-ds.y[0]).data
# dudx = (np.roll(v1[0].data,-1,axis=-2) - v1[0].data)/(ds.x[1]-ds.x[0]).data
# dvdy = (np.roll(v1[1].data,-1,axis=-1) - v1[1].data)/(ds.y[1]-ds.y[0]).data
divergence_calc = dudx+dvdy
print(divergence)
print(divergence_calc)
print(divergence.data.std())
print(divergence_calc.std())

v = v1
grid = cfd.grids.consistent_grid(*v)
if len(v) != grid.ndim:
  raise ValueError('The length of `v` must be equal to `grid.ndim`.'
                    f'Expected length {grid.ndim}; got {len(v)}.')
differences = [fd.backward_difference(u, axis) for axis, u in enumerate(v)]
# differences = [fd.central_difference(u, axis) for axis, u in enumerate(v)]

divergence = sum(differences)
# divergence = fd.centered_divergence(v1)
divergence_calc = dudx+dvdy
difference_1 = dudx - differences[0].data
difference_2 = dvdy - differences[1].data

# print(dudx)
# print(differences[0])
# print(dvdy)
# print(differences[1])

# print(np.abs(difference_1).shape)
location = np.unravel_index(np.argmax(np.abs(difference_1)), difference_1.shape)
# print(difference_1.min())
print(location)
# print(difference_1[164:168,212:216])
# print(difference_1[100:170,212:216])
print(dudx[100:170,214])
print(differences[0].data[100:170,214])


print(divergence)
print(divergence_calc)
print(np.abs(divergence.data).max())
print(np.abs(dudx+dvdy).max())